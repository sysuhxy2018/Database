# DBMS原理

### 事务

* 除了Auto Commit外，Commit或者Rollback标志着一个事务的结束。不存在Commit后再Rollback。
* 关于一致性(Consistency)，是指不能破坏数据库的完整性以及业务逻辑的一致性。事务开始前后，应该满足约束如check等。
* 关于隔离性，是指并发访问下，事务的执行是独立的。一个事务不能被另一个事务中间状态的数据所影响。数据只能处于事务修改前后的一致性状态。

补充：关于Commit和Rollback的简单用法，可以参考以下链接

> https://www.cnblogs.com/minigrasshopper/p/7803989.html

具体来说，就是必须start一个transaction，然后在事务结束的Commit或者Rollback。Commit还好理解，但Rollback感觉完全没用，如果不需要，不操作不就行了。后来细想，可能是用在函数里的，如在一个事务结束的时候结束检查某些条件，如果符合就Commit，不符合就Rollback撤回前面的所有操作。

### 封锁

* X锁不仅可以修改，还可以读。所以，如果又有修改又有读，直接用X锁。

* 意向锁引入IS和IX锁的原因：如果一个事务要加表级锁，则必须检查该表是否已经有表级锁或者行级锁。IS和IX锁表示该表已经有行级的S和X锁，无需逐行检查。所以，表级锁要检查X/S/IX/IS锁，而行级锁只要检查X/S锁。
* 到了第三级封锁协议，相当于读写数据前都会加一个X或者S锁，事务结束后才释放。
* 两段锁协议(2PL)类似于三级封锁协议，指事务结束前如果遇到要读写的数据时，则加锁；事务结束(Commit/Rollback)阶段才全部解锁。
  * 如果所有并发执行的事务都满足2PL，则并发执行的结果可以用某一组串行执行结果代替，称这组事务可串行化。另外，再次强调并发执行并不代表一定要同时开始，同时结束，而是一段时间内出现同时执行多个事务。
  * 2PL会出现死锁。具体解决方法可参考操作系统。

### 隔离级别

* 未提交读完全没用到锁或其他机制，隔离级别最低；提交读和可重复读用到了MVCC，一般也不需要锁；可串行化就是全部记录加行级锁，相当于强制事务串行执行，但是系统开销也很大。MySQL默认隔离级别为可重复读。
  * 这里说的不需要锁仅仅只是读不需要S锁，但写还是要X锁的（所有隔离级别都要）。这样读写不冲突，可以增加系统的并发性能。另外，由于读不需要加锁，所以只会出现写阻塞写这一种情况。
  * X锁可以避免丢失修改/脏写的问题，指的是事务的修改被另一个事务的修改所覆盖。
* 未提交读/脏读，指事务读取到了其他事务中未提交的数据；提交读/不可重复读，指事务只能获取其他已提交事务的修改，但存在由这些事务修改数据而产生的前后读取不一致的情况；可重复读无法解决幻读的问题，幻读指事务前后读取会由其他事务插入新的记录而出现不一致的情况。

### MVCC（多版本并发控制）

* 增删改查操作都是用该操作所处事务的版本号，而不是最新的系统版本号。而且所有的修改都不会覆盖/删除原有的数据，而是让新老版本共存。不过数据库会定期清理没用的数据。
* 有效的查找记录要求：
  * 行的创建版本号 <= 当前事务版本号
  * 行的删除版本号未定义或者 > 当前事务版本号
* 回滚日志(Undo Log)不仅可以用于Rollback，在MVCC中可以实现提交读和可重复读。每条记录自带一个回滚指针（新插入的为null），指向上一次修改的记录。即回滚日志相当于多版本记录的一个链表。
  * 结合上面有效查找记录的要求，可以通过回滚日志实现提交读和可重复读。提交读不需要满足第一条要求，即只要找到最新版本（创建版本号最大的）行即可；而可重复读需要找到所有满足记录中最新的版本（因为实际只能返回一个版本的数据）。
* 实际上比较的时候还需要维护一个Readview副本，即所有系统中所有活跃的事务（版本号）列表，然后根据列表中最大和最小的事务版本号以及行的创建版本号对应的事务是否在这个列表中筛选出合理的记录。
  * 这样做的目的是为了只得到已经Commit的记录，而上面的查找规则并不能保证这一点。需要将这两者结合得到正确的结果。

### Next-Key Locks

* MySQL中可重复读级别实际上解决了幻读问题，使用的是MVCC + Next-Key Locks。
* 间隙锁是一个左开右开区间，加上行锁就可以形成一个左开右闭区间，也就是Next-Key锁。Next-Key锁通过锁定特定的索引和索引间的间隙，可以阻塞新数据的插入，从而避免幻读。

### 范式

* 第一范式指属性不可分，即不能出现一个属性如爱好，有多个值如跑步、游泳等这样的情况。
* 第二范式指在满足第一范式的条件下，除所有候选键外的其他属性（非主键属性），要完全函数依赖于任意一组候选键，不能部分依赖。
  * 注意候选键可以有多组，如学号或者姓 + 名（不考虑重名）。一般只有一组候选键，即主键。
  * 简单说，就是不能出现一个非主键属性可以只用一组候选键中的一部分属性唯一确定的情况。
  * 如果出现了上面的情况，需要将数据表拆分成若干个表。即将非主键属性和对应候选键属性分离出来单独成表，原表中仍保留候选键，但删除分离出去的非主键属性。此外，还可能需要删除表里重复的行。
* 第三范式指在满足第二范式的条件下，非主键属性之间不能存在函数依赖关系，否则就会出现非主键属性传递函数依赖于候选键的情况。
  * 假设非主键属性B -> C，则可以将B，C分离出去单独成表。原表中仍保留B，删除C。如果C是某些可以计算得到的属性，如B是出生日期，C是年龄，则甚至不需要重新分表，直接删除C即可。

参考资料：

> https://www.jianshu.com/p/cb97f76a92fd
>
> https://www.jianshu.com/p/db334404d909
>
> https://www.cnblogs.com/liulvzhong/articles/9242299.html
>
> https://blog.csdn.net/w2064004678/article/details/83012387
>
> https://blog.csdn.net/shuaihj/article/details/14163713
>
> https://www.jianshu.com/p/6b5ee6f343a8





